# Spring Security 인증 상태 기반 로그인/로그아웃 버튼 구현 가이드

## 1. 질문: Authentication으로 isAnonymous/isAuthenticated 구분하여 버튼 만들기

### 목표
- `isAnonymous` (비로그인 상태) → 로그인 버튼 표시
- `isAuthenticated` (로그인 상태) → 로그아웃 버튼 표시

---

## 2. 현재 Users 폴더 파일 분석

### 파일별 역할 정리

| 파일 | 역할 | 인증 상태 확인 가능? |
|------|------|:-------------------:|
| `ApiLoginFilter.java` | `POST /auth/login` 요청 처리 | X |
| `ApiLoginSuccess.java` | 로그인 성공 시 사용자 정보 반환 | X (로그인 시점만) |
| `ApiLoginFail.java` | 로그인 실패 시 에러 반환 | X |
| `UsersController.java` | `POST /auth/register` 회원가입 | X |
| `UsersSecurityService.java` | Spring Security 인증 처리 | X (내부용) |
| `UsersRepository.java` | DB 조회 | X |
| `UsersService.java` | 사용자 생성 | X |
| `Users.java` | 엔티티 | - |
| `UsersRole.java` | Enum (STUDENT, INSTRUCTOR, ADMIN) | - |
| `UsersStatus.java` | Enum (ACTIVE, SUSPENDED) | - |

### 현재 존재하는 API
- `POST /auth/login` - 로그인 (ApiLoginFilter)
- `POST /auth/register` - 회원가입 (UsersController)
- `POST /auth/logout` - 로그아웃 (SecurityConfig)

### 없는 것
- `GET /auth/me` - 현재 인증 상태 확인 API

---

## 3. 결론: 현재 코드만으로는 인증 상태 확인 불가

로그인/로그아웃 **기능 자체**는 구현되어 있습니다.
하지만 프론트엔드에서 **현재 인증 상태를 확인**하는 API가 없습니다.

---

## 4. 해결 방법: `/auth/me` API 추가

### 백엔드 - UsersController.java에 추가

```java
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;

@GetMapping("/me")
@ResponseBody
public ResponseEntity<?> getCurrentUser() {
    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
    Map<String, Object> response = new HashMap<>();

    // 비로그인 상태 체크 (isAnonymous)
    boolean isAnonymous = (auth == null ||
                           !auth.isAuthenticated() ||
                           "anonymousUser".equals(auth.getPrincipal()));

    if (isAnonymous) {
        response.put("authenticated", false);
        return ResponseEntity.ok(response);
    }

    // 로그인 상태 (isAuthenticated) - 사용자 정보 포함
    Users user = usersRepository.findByLoginId(auth.getName())
                                .orElse(null);
    response.put("authenticated", true);
    if (user != null) {
        response.put("userId", user.getUserId());
        response.put("loginId", user.getLoginId());
        response.put("name", user.getName());
        response.put("role", user.getRole());
    }

    return ResponseEntity.ok(response);
}
```

### UsersController에 UsersRepository 주입 필요

```java
@RequiredArgsConstructor
public class UsersController {
    private final UsersService usersService;
    private final UsersRepository usersRepository;  // 추가
    ...
}
```

### 프론트엔드 - StudentNav.jsx 수정

```jsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function StudentNav() {
    const [isAuthenticated, setIsAuthenticated] = useState(false);

    useEffect(() => {
        // 인증 상태 확인
        axios.get('http://localhost:8080/auth/me', { withCredentials: true })
            .then(res => setIsAuthenticated(res.data.authenticated))
            .catch(() => setIsAuthenticated(false));
    }, []);

    return (
        <nav>
            {/* 조건부 렌더링 */}
            {!isAuthenticated ? (
                // isAnonymous -> 로그인 버튼
                <Button>
                    <Link to="/auth/login">로그인</Link>
                </Button>
            ) : (
                // isAuthenticated -> 로그아웃 버튼
                <Button onClick={handleLogout}>
                    로그아웃
                </Button>
            )}
        </nav>
    );
}
```

---

## 5. 핵심 포인트

| 상태 | Spring Security | 표시 버튼 |
|------|-----------------|----------|
| 비로그인 | `principal == null` (isAnonymous) | 로그인 버튼 |
| 로그인 | `principal != null` (isAuthenticated) | 로그아웃 버튼 |

---

## 6. 질문: 인증 상태 확인 API가 있어야 유저별 데이터 저장이 가능한가?

### 답변: 아니요, 그건 다른 개념입니다

### 두 가지 개념 구분

| 용도 | 필요한 것 | 설명 |
|------|----------|------|
| **프론트엔드 UI 표시** | `/auth/me` API | 로그인/로그아웃 버튼, 메뉴 표시 |
| **백엔드 사용자별 데이터 처리** | `Principal` / `Authentication` | 마이페이지, 수강내역 등 |

### 백엔드에서 사용자 식별하는 방법 (이미 가능)

로그인하면 **세션 쿠키**에 인증 정보가 저장됩니다.
각 API에서 `Principal`로 현재 사용자를 확인할 수 있습니다:

```java
// 예: 수강생의 강의 시청 내역 조회
@GetMapping("/my/progress")
public ResponseEntity<?> getMyProgress(Principal principal) {
    String loginId = principal.getName();  // 현재 로그인한 사용자
    // loginId로 해당 유저의 데이터만 조회/저장
    return ResponseEntity.ok(progressService.findByLoginId(loginId));
}

// 예: 강사의 강좌 개설 신청
@PostMapping("/course/apply")
public ResponseEntity<?> applyCourse(@RequestBody CourseDto dto, Principal principal) {
    String loginId = principal.getName();
    // 이 강사의 강좌로 저장
    courseService.apply(dto, loginId);
    return ResponseEntity.ok("신청 완료");
}
```

### 용도 정리

```
/auth/me API 용도:
├── 프론트엔드에서 "지금 로그인 상태인가?" 확인
├── 로그인 버튼 vs 로그아웃 버튼 표시
└── 역할에 따른 메뉴 표시 (학생/강사/관리자)

Principal 용도:
├── 백엔드에서 "이 요청을 누가 보냈는가?" 확인
├── 해당 사용자의 데이터만 조회/저장
└── 권한 체크 (@PreAuthorize)
```

### 결론

**유저별 데이터 저장/조회**는 `Principal`로 이미 가능합니다.

`/auth/me`는 **프론트엔드 UI용**입니다 (버튼 표시, 메뉴 분기 등).

---

## 7. 부록: localStorage 방식의 문제점

### `/auth/me` API 대신 localStorage 사용 시 문제

```
시나리오:
1. 로그인 성공 → localStorage에 {loginId: "user1", name: "홍길동"} 저장
2. 프론트엔드: localStorage 있으니까 "로그아웃 버튼" 표시
3. 30분 후 세션 만료 (백엔드에서 세션 삭제됨)
4. 프론트엔드: localStorage는 그대로 → 여전히 "로그아웃 버튼" 표시
5. 사용자가 "마이페이지" 클릭 → API 호출 → 401 Unauthorized 에러!
```

### 화면에 남는 것

| 항목 | 남는가? |
|------|:------:|
| 로그아웃 버튼 (로그인 상태처럼 보임) | O |
| 마이페이지 메뉴 | O |
| **실제 사용자 데이터 (수강내역, 이력 등)** | X |

**데이터는 안 남습니다.** API 호출해야 데이터를 가져오는데, 세션 만료되면 401 에러 나서 데이터 못 가져옵니다.

### `/auth/me` API가 권장되는 이유

```jsx
// 페이지 로드 시 서버에 직접 확인
const checkAuth = async () => {
    const res = await axios.get('/auth/me', { withCredentials: true });
    if (res.data.authenticated) {
        // 진짜 로그인 상태 → 로그아웃 버튼
    } else {
        // 세션 만료됨 → 로그인 버튼
        localStorage.clear();  // localStorage도 정리
    }
};
```

**서버와 동기화**되어서 정확한 상태를 표시할 수 있습니다.
